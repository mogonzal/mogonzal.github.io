(self.webpackChunkmogonzal_website=self.webpackChunkmogonzal_website||[]).push([[252],{5436:function(e,t,n){"use strict";n.r(t),n.d(t,{Head:function(){return h},default:function(){return p}});var a=n(1151),o=n(7294),i=n(3779),r=n(7947),l=n.p+"static/election_cycle-c12e9741b0b7965cafc875d949ad91e1.png",s=n.p+"static/explorer-61596305480838d144168fb32944b4b8.png";function c(e){const t=Object.assign({p:"p",em:"em",strong:"strong"},(0,a.ah)(),e.components);return o.createElement(o.Fragment,null,o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," tl;dr "),"\n",o.createElement(t.p,null,"I helped design a secure proof-of-stake cryptocurrency using VRFs. Below, I detail the project as written in our paper."),"\n",o.createElement("br"),"\n",o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," Introduction "),"\n",o.createElement(t.p,null,"There is no doubt that Bitcoin uses a lot of energy. According to estimates by the Cambridge Center for Alternative\nFinance, the Bitcoin network currently uses 133 TWh of energy per year to support the mining process: approximately the\nsame amount as all of Sweden. A single Bitcoin transaction uses 707.6 KWh of energy. There is a currently a high-profile\ndebate as to the extent of Bitcoin’s current and future role in climate change. The exact breakdown of energy sources\nused in Bitcoin mining is unknown, but there is evidence that a sizable portion of the network still uses coal as their\nprimary energy source. A large flood in a coal mine in Xinjiang, China over April 17-18, 2021 coincided with a full 1/3\nreduction in the Bitcoin network’s computing power. If the reliance on fossil fuels continues, Bitcoin will be a large\nunnecessary contributor to global carbon emissions."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"In direct contrast, proponents of Bitcoin argue that the Bitcoin network is a useful tool to accelerate global adoption\nof renewable energy sources necessary to halt climate change. Since renewable energy sources produce volatile energy\noutput that fluctuates with the weather, they must be built far above capacity. Additionally, the best locations for\nbuilding renewable energy farms are often in remote areas with little demand to justify the cost of construction.\nBitcoin miners act as unique energy buyers that buy cheap energy during output peaks. In this manner, Bitcoin could be\nused as an economic battery to accelerate construction of renewable energy farms. Regardless of the possible merits\njustifying its high energy usage, Bitcoin alone is an unjustifiably slow and inefficient solution for high throughout\nDeFi and NFT applications. Alternative consensus mechanisms must be used as part of Layer 2 side-chain solution in order\nto scale PoW cryptocurrencies efficiently."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Bitcoin has not always used so much energy. According to the CCAF, Bitcoin only used around 6.7 TWh per year as late as\n2017. Speculative investment in Bitcoin has caused its price to exponentially increase. Since the block reward rate is\nnot tied to the market price of Bitcoin, large jumps in the Bitcoin price increase the profitability of mining Bitcoin\nand incentivizes more miners to join the network. Since Bitcoin rewards miners with Bitcoin roughly in proportion to\ntheir energy usage, one might expect Bitcoin energy usage to strictly increase if the price of Bitcoin rises. However,\nthe Bitcoin block reward rate paid to miners is cut in half approximately once every four years. As long as the Bitcoin\nprice does not continue to double more frequently than every four years, energy usage is expected to level out or even\ndecrease. However, if the Bitcoin price continues to rise at a rapid rate, energy usage could increase further in the\nshort term. Bitcoin miners receive a small fee from all transactions included in their block. Once the block reward has\ndecreased to zero, transaction fees will be the sole source of revenue for miners. In order for the Bitcoin system to\nremain usable, there is a theoretical upper cap on the real world value of a transaction fee. Since the maximum number\nof transactions per block is fixed, there is a theoretical upper limit on the Bitcoin mining revenue. This also enforces\nan theoretical upper limit on energy usage in the long term."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"In our paper, we define a PoS cryptocurrency that uses VRF based leader selection protocol in tandem with the Ten-\ndermint BFT finality gadget. Unlike other notable solutions which use a threshold-based VRF leader selection protocol\nwhich may elect multiple leaders or none at all, we define a network protocol which forms consensus on the global\nminimum VRF across the entire network. This approach makes the network extremely resilient to DoS attacks since the\nleader is not known by any node—including the leader—prior to consensus. Additionally, we create a REST API that\nnode operators may optionally host which allows users to view the blockchain state using a React blockchain explorer\nfrontend hosted on Github pages."),"\n",o.createElement("br"),"\n",o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," Background "),"\n",o.createElement(t.p,null,"Cryptocurrencies are built on top of unstructured peer-to-peer networks commonly known as ",o.createElement(t.em,null,"gossip networks"),". In a gossip\nnetwork, each node is connected to a small set of other nodes. Upon receiving a message, each node forwards the message\nto each of its peers. As long as the network is fully connected, any message ",o.createElement(t.em,null,"broadcasted")," by any node should eventually\nreach every other node in the network unaltered. However, if malicious nodes are present in the network, this may not\nnecessarily be the case. A malicious node in the network may arbitrarily choose not to forward messages. As long as\nremoving all malicious nodes from the network does not partition the non-malicious nodes into two disconnected\ncomponents, this does not prevent a message from reaching all nodes in the network. A malicious node in the network may\nattempt to alter the contents of a message. This can be prevented using ",o.createElement(t.em,null,"cryptographic signatures"),". If a node signs a\nmessage before broadcasting it to the network, then all other nodes can ",o.createElement(t.em,null,"verify")," that the message has not been altered\nbefore propagating it further."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Low-risk distributed protocols often make ",o.createElement(t.em,null,"timing assumptions")," about the network to simplify application logic. For\ninstance, web browsers have a preset timeout for HTTP requests after which they assume a response will never arrive.\nSince latency between nodes on a gossip network may vary wildly and security is of the utmost important to a\ncryptocurrency, it is important to understand and fully consider any timing assumptions made by cryptocurrency systems.\nIn a ",o.createElement(t.strong,null,"synchronous")," network, we assume that all messages will arrive within some known upper time bound. This\nassumption is often made for distributed systems with lower security standards since it greatly simplifies analysis. For\na high stakes application like a cryptocurrency, this is a dangerous assumption to make, since even a single message\narriving outside of the latency upper bound can affect the security of the system. In an ",o.createElement(t.strong,null,"asynchronous")," network, we\nassume that all messages will eventually arrive, but there is no time bound on the message delay. Systems designed for\nan asynchronous network are more secure at the cost of complexity. The FLP impossibility result proved that it is\nimpossible for a asynchronous distributed system to achieve deterministic consensus in the event that a single node\nmalfunctions. Probabilistic algorithms, such as HBBFT or DUMBO achieve consensus in an asynchronous setting with\noverwhelming probability at the cost of complexity. In a ",o.createElement(t.strong,null,"semi-synchronous")," network, we assume that messages delay\nfollows a probability distribution such that for any ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon \\in (0,1]"}),", there\nexists a ",o.createElement(r.Z,{displayMode:"inline",formula:"\\Delta t"})," such that the probability that a message have a latency\ngreater than ",o.createElement(r.Z,{displayMode:"inline",formula:"\\Delta t"})," is less than ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon"}),". The semi-synchronous network assumption is a convenient middle ground that is much more realistic\nthan a synchronous network assumption, yet far more practical than asynchronous network assumptions."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"The foundation of all prominent cryptocurrencies is a distributed database—often referred to as the ",o.createElement(t.em,null,"ledger"),"—that\nmaintains the balance of all account holders. Unlike other distributed databases, cryptocurrency networks satisfy the\nfollowing important properties:"),"\n",o.createElement("br"),"\n",o.createElement("ul",{className:"list-disc list-inside"},o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"Immutable History"),": Once a transaction is added to the database, it cannot be modified or removed. The entire\nhistory of transactions can be viewed and audited like a traditional financial ledger.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"Byzantine Fault Tolerance"),": If any well-behaved node adds a transaction to their local copy of the database, then\nall well-behaved nodes will eventually add the same transaction to their database.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"Nash Equilibrium"),": Nodes are fairly incentivized to operate in a correct manner as dictated by the network\nspecification. Deviation from correct behavior should strictly hurt nodes."))),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"In order to achieve the ",o.createElement(t.em,null,"immutable history")," property, a cryptocurrency network structures the database as a\n",o.createElement(t.em,null,"blockchain"),". A blockchain is a linked-list of ",o.createElement(t.em,null,"blocks")," in which each block references the previous block by its\n",o.createElement(t.em,null,"cryptographic hash"),". Each block contains a set of transactions that modify the database state at the previous block. In\nthis manner, a blockchain implicitly stores the database state at every point in time. To modify the database state, a\n",o.createElement(t.em,null,"leader")," is chosen to propose the next block. Since a blockchain is intended to be an immutable ledger, it is important\nfor nodes in the system to eventually achieve consensus on the state of the system. A block ",o.createElement(r.Z,{displayMode:"inline",formula:"b"})," at height ",o.createElement(r.Z,{displayMode:"inline",formula:"h"})," is ",o.createElement(t.em,null,"finalized")," when it is common knowledge that all\nwell-behaved nodes in the system agree that ",o.createElement(r.Z,{displayMode:"inline",formula:"b"})," is the unique valid block at\nheight ",o.createElement(r.Z,{displayMode:"inline",formula:"h"}),". Bitcoin and Tezos achieves ",o.createElement(t.em,null,"probabilistic finality")," in that the\nprobability of a block being finalized approaches 1 as more blocks are added. Algorand uses a byzantine-agreement\nalgorithm to achieve ",o.createElement(t.em,null,"deterministic finality")," in that consensus is reached as soon as a block is added to the\nblockchain."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"In a ",o.createElement(t.strong,null,"proof-of-work")," system, each node competes to be the first to create a block with a ",o.createElement(t.em,null,"hash")," that is less than some\nconstant value and broadcast it to the rest of the network. The probability of each node being the first to solve the\nproblem is directly proportional to the speed at which they can compute cryptographic hashes. Each node independently\nconsiders the current state of the database to be defined by the longest correct chain of blocks and the ",o.createElement(t.em,null,"leader")," of\neach round to be the first node to solve the problem for a block that adds onto the longest correct chain of blocks. A\n",o.createElement(t.strong,null,"Nash equilibrium")," is incentivized by rewarding the leader by increasing their account balance. In this fully\nasynchronous model, two or more nodes may solve the hashing problem at approximately the same time, and the network may\ndisagree on the current state of the database, so the network only reaches consensus with high probability after a\nsufficient number of blocks are added to the network."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"In a ",o.createElement(t.strong,null,"proof-of-stake")," cryptocurrency, a Nash equilibrium is incentivized by rewarding nodes in proportion to their\n",o.createElement(t.em,null,"stake")," (account balance) in the network similar to an interest rate. Nodes that do not correctly participate may not\nreceive a reward or even be penalized by with a decreased account balance. Similarly, nodes collectively ",o.createElement(t.em,null,"vote")," in\nproportion to their stake, which prevent ",o.createElement(t.em,null,"sybil attacks"),". A large real-world investment is required to gain significant\ncontrol over the network. There are a wide variety of block proposal (leader selection) and consensus mechanisms in use\nby proof-of-stake cryptocurrencies."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Popular cryptocurrencies such as Binance Coin (BNB) using the tendermint-core blockchain utilize a weighted round-robin\nleader election protocol in order to decide which node should propose a block each round. The round-robin process cycles\nthrough all nodes in a pre-determined way such that each node is chosen to be leader in proportion to their relative\nstake in the network. This process uniquely selects a single leader for each round, but also allows a DoS attack to be\nefficiently executed since the leader of each round is known far in advance. A better theoretical model for blockchain\nleader election is the ",o.createElement(t.em,null,"single secret random leader election")," (SSRE). A SSRE is a distributed process in which exactly\none node is chosen to be leader. The election is ",o.createElement(t.em,null,"random")," in that nodes are randomly chosen according to some\npredetermined distribution. The election is ",o.createElement(t.em,null,"secret")," in that only the leader knows that they are chosen, but the leader\ncan provide a ",o.createElement(t.em,null,"proof")," to other nodes that they were chosen."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"A ",o.createElement(t.em,null,"verifiable random function")," ",o.createElement(r.Z,{displayMode:"inline",formula:"F: \\{0, 1\\}^{a} \\to \\{0,\n1\\}^{b}"})," has an associated a set of functions ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{(Gen, Prove, Ver)}"})," such\nthat ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Gen}(R) = (PK, SK)"})," generates a public-secret key pair, ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Prove}_{SK}(x) = (y = F_{SK}(x), \\pi_{SK}(x))"})," generates a number ",o.createElement(r.Z,{displayMode:"inline",formula:"y"})," and proof ",o.createElement(r.Z,{displayMode:"inline",formula:"\\pi"})," such that ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Ver}_{PK}(x, y, \\pi) = 1"})," if and only if ",o.createElement(r.Z,{displayMode:"inline",formula:"y =\nF_{SK}(x)"}),". Importantly, the output of ",o.createElement(r.Z,{displayMode:"inline",formula:"F"})," must also be indifferentiable from\nthe uniform distribution. It is important to note that a VRF satisfies all the properties of a cryptographic signature\nwith the additional requirements of uniqueness and uniform randomness. The VRF was first invented by Algorand founder\nSilvio Micali."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"There are a couple of notable solutions that utilize the VRF to construct a random leader election. The Blind Assignment\nfor Blockchain Extension (BABE) protocol uses a VRF threshold method to elect all nodes whose VRF for a round is less\nthan a predetermined constant. This process may elect multiple leaders or may elect no leaders at all. A byzantine\nagreement can later be used to arbitrarily choose a single block from the set of potential blocks proposed by the\nleaders The Algorand protocol uses a VRF threshold method to select small committees from the full set of nodes. Each\nnode in the committee proposes a block and the committee runs a byzantine agreement to determine the minimum VRF among\nall nodes in the committee."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"A byzantine agreement is a distributed protocol used to achieve consensus among nodes where some fraction ",o.createElement(r.Z,{displayMode:"inline",formula:"f"})," of the nodes may be faulty or even malicious. A malicious node may send an incorrect\nnetwork message, send a network message at the wrong time, or fail to send a message at all. More formally, every\nbyzantine agreement must satisfy two important properties. A byzantine agreement satisfies the ",o.createElement(t.strong,null,"safety")," property if\nthe protocol guarantees that if any non-faulty node decides upon some value ",o.createElement(r.Z,{displayMode:"inline",formula:"v"}),",\nthen all non-faulty nodes will eventually decide upon the same value v given that ",o.createElement(r.Z,{displayMode:"inline",formula:"f\n< k"}),". A byzantine agreement satisfies the ",o.createElement(t.strong,null,"liveness")," property if the protocol guarantees that some non-faulty node\nwill eventually decide upon some value ",o.createElement(r.Z,{displayMode:"inline",formula:"v"})," given that ",o.createElement(r.Z,{displayMode:"inline",formula:"f < k"}),". Below, we detail the popular ",o.createElement(t.strong,null,"Tendermint byzantine agreement")," and provide a proof of safety. The\nTendermint byzantine agreement makes semi-synchronous network assumptions. Although we do not currently use it in our\nimplementation, this protocol could be used to guarantee both safety and liveness in our cryptocurrency."),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-fit"},o.createElement(i.p,{language:""},"t = 60;\nR = 1;\nB = createBlock(...);\nI = 0;\nL = false;\n\nwhile (true) {\n  broadcast (propose, H, R, B);\n  while (T * R seconds have not elapsed) {\n    upon receiving (propose, H', R', B');\n    if (I = 0 and L = false and H = H' and R = R' and L = L' and priority(B) > priority(B')) {\n      B = B'\n    }\n    else if (I != 0 and B contains proof of +2/3 prevote at round I(B') > I) {\n      B = B';\n      I = I(B');\n    }\n  }\n  broadcast (prevote, H, R, B);\n  while (T * R seconds have not elapsed or no +2/3 prevote with (H, R)) {\n    upon receiving vote = (prevote, H', R', B') add vote to list;\n  }\n  if (+2/3 prevote B) {\n    L = true;\n    broadcast (precommit, H, R, B)\n  }\n  else if (+2/3 prevote B') {\n    L = false;\n    broadcast (precommit, H, R, null)\n  }\n  else {\n    broadcast (precommit, H, R, null)\n  }\n  while (T * R) seconds have no elapsed or no +2/3 precommit with (H, R)) {\n    upon receiving vote = (precommit, H', R', B') add vote to list;\n  }\n  if (+2/3 precommit B) {\n    broadcast (commit, H, R, B)\n  }\n  else {\n    broadcast (commit, H, R, null)\n  }\n}\n"))),"\n",o.createElement(t.p,null,"We will prove that this protocol satisfies the ",o.createElement(t.strong,null,"safety")," property: if any node decides upon a block, all correct nodes\nwill eventually decide upon the same block. If less than 1/3 of the nodes are faulty and a correct node receives a +2/3\nmajority ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Prevote}"}),", then it knows that +1/2 of the correct nodes have the\nsame block. If that same node then receives a +2/3 majority ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Precommit}"}),",\nthen it knows that +1/2 of the correct nodes have the same block and also know that they have the same block. Since a\ncorrect node locks in a block when they know that +1/2 of the correct nodes have the same block, the node also knows\nthat +1/2 of the correct nodes have locked in to ",o.createElement(r.Z,{displayMode:"inline",formula:"B"}),". A correct node will only unlock when they know that +1/2 of the\ncorrect nodes have a different block from them. This will never happen since +1/2 of the correct nodes are locked. A\ncorrect node will only commit a block if this is true."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"If any correct node commits a block ",o.createElement(r.Z,{displayMode:"inline",formula:"B"}),", then some set of +1/2 of the correct\nnodes must have either already committed ",o.createElement(r.Z,{displayMode:"inline",formula:"B"})," or be currently locked on ",o.createElement(r.Z,{displayMode:"inline",formula:"B"}),". In a fully asynchronous network, there is no guarantee that +1/2 correct nodes\nlocked on ",o.createElement(r.Z,{displayMode:"inline",formula:"B"})," will be able to communicate with each other. However, if we instead\nassume a semi-synchronous network, the probability that each of the +1/2 correct nodes will receive the ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Prevote}"})," and ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Commit } B"})," messages\nfrom the rest of the +1/2 correct nodes approaches 1 as ",o.createElement(r.Z,{displayMode:"inline",formula:"R \\rightarrow \\infty"}),".\nOnce the +1/2 correct nodes commit their blocks and broadcast a ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Commit } B"}),"\nmessage, the rest of the nodes will eventually receive +1/2 ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Commit } B"}),"\nmessages and ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{Commit } B"})," the block themselves."),"\n",o.createElement("br"),"\n",o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," Our System "),"\n",o.createElement(t.p,null,"We model our system as an infinite repeating game of ",o.createElement(t.strong,null,"random leader elections"),", in which a fixed set of ",o.createElement(r.Z,{displayMode:"inline",formula:"n"})," agents compete to generate the smallest random number. We then propose protocols for\nan ",o.createElement(t.strong,null,"iterated")," random leader election, security during ",o.createElement(t.strong,null,"volatile player sets"),", construction of a ",o.createElement(t.strong,null,"blockchain")," using\nthe election process, and minor modifications resulting in a weighted ",o.createElement(t.strong,null,"proof-of-stake")," system."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"At each time step ",o.createElement(r.Z,{displayMode:"inline",formula:"t"}),", we seek to elect a random leader among all agents (this\nleader will add the next block to the chain). At a base level, the election process should be both ",o.createElement(t.em,null,"random")," (election\nparameters are not easily manipulatable) and ",o.createElement(t.em,null,"equitable")," (each agent has the same chance of being elected). We propose\nthe following election process and defend it against the bolded criteria. Initially, all agents ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," generate a random number ",o.createElement(r.Z,{displayMode:"inline",formula:"R_i"})," and a\npublic-private key pair ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{GEN}(R_i) = (PK_i, SK_i) B"}),". Agents know ",o.createElement(r.Z,{displayMode:"inline",formula:"PK_i"})," for all other agents, but have no knowledge of ",o.createElement(r.Z,{displayMode:"inline",formula:"R_i"})," or other ",o.createElement(r.Z,{displayMode:"inline",formula:"SK_i"}),". During each round ",o.createElement(r.Z,{displayMode:"inline",formula:"k"})," with random seed ",o.createElement(r.Z,{displayMode:"inline",formula:"T_k"}),", all agents compute and publish their random\nnumber and proof defined below:"),"\n",o.createElement(r.Z,{displayMode:"block",formula:"(y_i, \\pi_i) = F_{SK_i}(T_k)"}),"\n",o.createElement(t.p,null,"The winner of the round is the agent with the smallest ",o.createElement(r.Z,{displayMode:"inline",formula:"y_i"})," such that ",o.createElement(r.Z,{displayMode:"inline",formula:"\\text{VER}_{PK_i}(T_k, y_i, \\pi_i) = 1"}),". In other words, each agent generates a random\nnumber using the VRF and broadcasts it to the network. The elected agent is the one with the smallest verified ",o.createElement(r.Z,{displayMode:"inline",formula:"y_i"}),"."),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-1/3"},o.createElement("img",{src:l,alt:"Election cycle",className:"w-full h-auto"}))),"\n",o.createElement(t.p,null,"Assuming the VRF works as assumed, we see that this method is both ",o.createElement(t.strong,null,"random")," and ",o.createElement(t.strong,null,"equitable")," by construction. The\nrandom number assigned to each agent depends only on their secret key and the current seed, where the secret key is\nchosen without their knowledge and the current seed becomes increasingly random with successive rounds (proof of this is\nshown later). Additionally, since each agent gets a singular random number, the likelihood of being elected does not\nvary between agents."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Once a leader has been randomly elected at round ",o.createElement(r.Z,{displayMode:"inline",formula:"k"}),", we must then set up the seed\nfor round ",o.createElement(r.Z,{displayMode:"inline",formula:"k+1"})," in a ",o.createElement(t.strong,null,"secure")," manner. An easy way to accomplish this is by\nintroducing some aspect of randomness in order to prevent the possibility of any malicious agents purposefully\ngenerating a seed of their choice. Thus, we propose the following simple scheme to generate a new random ",o.createElement(r.Z,{displayMode:"inline",formula:"T"})," for each round and argue its security below:"),"\n",o.createElement(r.Z,{displayMode:"block",formula:"T_{k+1} = H(T_k|PK_w)"}),"\n",o.createElement(t.p,null,"Here ",o.createElement(r.Z,{displayMode:"inline",formula:"H"})," is a random oracle and ",o.createElement(r.Z,{displayMode:"inline",formula:"w"})," is the\nagent who won round ",o.createElement(r.Z,{displayMode:"inline",formula:"k"}),". The use of ",o.createElement(r.Z,{displayMode:"inline",formula:"H"}),"\nintroduces the aspect of main aspect of randomness. Additionally, the inclusion of both ",o.createElement(r.Z,{displayMode:"inline",formula:"T_k"})," and ",o.createElement(r.Z,{displayMode:"inline",formula:"PK_w"})," serves to supplement this with additional factors that\nare hard to determine for asymptotically large numbers of agents."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"We will show that this method of election is ",o.createElement(t.strong,null,"secure")," by examining the asymptotic probability that any malicious agent\ncan guarantee their odds of winning successive rounds. It is possible for an agent ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," with prior knowledge of the initial seed ",o.createElement(r.Z,{displayMode:"inline",formula:"T_0"})," to generate many\ndifferent random numbers ",o.createElement(r.Z,{displayMode:"inline",formula:"R_i"})," in order to minimize their value ",o.createElement(r.Z,{displayMode:"inline",formula:"F_{SK}(T_0)"})," prior to entering the game. The probability of randomly picking a number\n",o.createElement(r.Z,{displayMode:"inline",formula:"x_0 < \\epsilon"})," from the random distribution ",o.createElement(r.Z,{displayMode:"inline",formula:"U \\in [0, 1]"})," is ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon"}),". The expected count of random numbers\n",o.createElement(r.Z,{displayMode:"inline",formula:"R"})," that must be generated before this bound is reached is ",o.createElement(r.Z,{displayMode:"inline",formula:"1/\\epsilon"}),". Assuming that generating a value less than ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon"})," is sufficient to guarantee a win with high enough probability, agent ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," can guess ",o.createElement(r.Z,{displayMode:"inline",formula:"T_1 = H(T_0|PK_i)"})," with high probability. The likelihood\nof winning for the first ",o.createElement(r.Z,{displayMode:"inline",formula:"k"})," rounds of the game is ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon^k"}),", which requires an expected ",o.createElement(r.Z,{displayMode:"inline",formula:"1/\\epsilon^k"})," tries."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"To ensure a win for ",o.createElement(r.Z,{displayMode:"inline",formula:"k"})," cumulative rounds with probability ",o.createElement(r.Z,{displayMode:"inline",formula:"p"}),", agent ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," must win each round with probability\n",o.createElement(r.Z,{displayMode:"inline",formula:"p^{1/k}"}),". For some ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon"}),", if all other\nagents are non-malicious and pick truly random numbers, the probability of winning a given round is ",o.createElement(r.Z,{displayMode:"inline",formula:"(1-\\epsilon)^n"}),". Thus, the agent would need to choose ",o.createElement(r.Z,{displayMode:"inline",formula:"\\epsilon = 1 - p^{1/kn}"}),". Doing so would require an expected ",o.createElement(r.Z,{displayMode:"inline",formula:"1/(1 -\np^{1/kn})^k"})," attempts with random seeds. Even for small values of ",o.createElement(r.Z,{displayMode:"inline",formula:"k"})," and ",o.createElement(r.Z,{displayMode:"inline",formula:"n"}),", this value quickly approaches infinite. For example, a game with 10 agents would\nrequire malicious agent ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," to attempt ",o.createElement(r.Z,{displayMode:"inline",formula:"7.54\n\\cdot 10^{32}"})," seeds in order to find one ensuring election for 10 rounds with probability 0.95."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"It is important to note that as soon as agent ",o.createElement(r.Z,{displayMode:"inline",formula:"i"})," enters the game, they have no\nway to chance their random number. As soon as they lose a round, they lose all benefit from preemptively computing many\ndifferent values of ",o.createElement(r.Z,{displayMode:"inline",formula:"R"}),". However, this is not necessarily the case if we allow\nagents to enter and exit the game at will. If this were the case, any agent could perform a brute-force optimization to\nforce their election in the game at any time (albeit for a small number of rounds limited by their computational\nresources as shown above). Assuming all agents act independently, this can be remedied by forcing all new agents to\ndeclare their public key at least two rounds before they start playing."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Dropping the assumption that agents act independently, a coalition of agents could collectively win for an arbitrary\nnumber of rounds in the following manner. Before the game starts, ",o.createElement(r.Z,{displayMode:"inline",formula:"a_0"})," could\npre-compute their seed to force a win on rounds 0 to 2. During round 0, ",o.createElement(r.Z,{displayMode:"inline",formula:"a_0"}),"\ncould tell ",o.createElement(r.Z,{displayMode:"inline",formula:"a_1"})," what ",o.createElement(r.Z,{displayMode:"inline",formula:"T_3"})," will be and\n",o.createElement(r.Z,{displayMode:"inline",formula:"a_1"})," could pre-compute their seed to win rounds 3 and 4, then join the game\nduring round 1 in time to play round 3. During rounds 1 and 2, ",o.createElement(r.Z,{displayMode:"inline",formula:"a_1"})," could tell\n",o.createElement(r.Z,{displayMode:"inline",formula:"a_2"})," what ",o.createElement(r.Z,{displayMode:"inline",formula:"T_5"})," will be, and the process\ncontinues. In this manner, as long as the agents can collectively pre-compute seeds faster than the game runs, their\ncoalition can collectively dominate the game."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"It is easier for a coalition to force a win over an arbitrary number of rounds because each agent only needs to compute\na seed that forces a win over 2 rounds: a significantly easier problem. This problem can be remedied by forcing all\nagents to declare their public key further in advance. The amount of work per agent to perform a chained coalition\nattack increases exponentially with the number of rounds that an agent must join. Depending on the initial number of\nplayers and the expected payoff of winning a round, this value can be fixed so that it is computationally and\neconomically infeasible for a chained coalition attack to occur."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"We use the iterated random leader election above to build a blockchain in the following manner: when broadcasting a VRF\nproof for each round of the iterated election process, each node also proposes the next block in the blockchain. After\nreceiving a VRF proof from each node, the block associated with the minimum VRF is ",o.createElement(t.em,null,"committed")," to the blockchain. The\nbenefit of this approach is that it is quite simple. However, a malicious node may create a ",o.createElement(t.strong,null,"fork")," in the system by\nproposing multiple blocks with the same VRF for each round. This vulnerability can be resolved easily by requiring all\nnodes to store the set of blocks associated with the VRF for each round. When proposing a block, each node must choose\nexactly one fork to build upon. Thus, as long as at least one well-behaved node is eventually elected leader, all forks\nwill eventually be resolved. We characterize this property as ",o.createElement(t.strong,null,"eventually fork-free"),". After adding a Blockchain\nconstruct into the leader election protocol, in the absence of malicious nodes that propose multiple blocks when\nelected, each node knows the account balance of every other at every stage of the game. In presence of malicious nodes,\neach node knows the account balance of every other node with high probability after enough rounds have passed."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"The ",o.createElement(t.strong,null,"fairness")," property of the leader election proposed above is conditional on the assumption that each agent can\nonly create a single node. This is an unrealistic assumption, a single agent can win more elections by creating more\nnodes each with their own unique keypairs. To prevent this, we modify the iterated leader election protocol to randomly\nselect each node with a probability equal to the node’s account balance divided by the sum of the account balance of all\nnodes in the network. Under this construction, a proof-of-stake cryptocurrency is ",o.createElement(t.strong,null,"fair")," if the expected reward at\neach round of the leader election is proportional to wealth at the previous round. We propose a modification to the\ninitial iterated leader selection protocol that is ",o.createElement(t.strong,null,"approximately fair"),". For round ",o.createElement(r.Z,{displayMode:"inline",formula:"k"})," with random seed ",o.createElement(r.Z,{displayMode:"inline",formula:"T_k"})," and scaling factor ",o.createElement(r.Z,{displayMode:"inline",formula:"S"}),", we assign each node with balance ",o.createElement(r.Z,{displayMode:"inline",formula:"W_k"})," a\npriority ",o.createElement(r.Z,{displayMode:"inline",formula:"y_i"}),"."),"\n",o.createElement(r.Z,{displayMode:"block",formula:"(y_i, \\pi_i) = \\min_{n=1,\\ldots, \\lfloor W_k / S \\rfloor}\\{(y_n = F_{SK}(T_k + n), \\pi_n)\\}"}),"\n",o.createElement(t.p,null,"The scaling factor ",o.createElement(r.Z,{displayMode:"inline",formula:"S"})," is chosen based on the maximum total supply in order to\nlimit the computational complexity of choosing the minimum priority at each round. When ",o.createElement(r.Z,{displayMode:"inline",formula:"S=1"})," this is a ",o.createElement(t.strong,null,"fair")," random election. An unfortunate side effect of scaling the votes is that probability\nof winning the election is not exactly equal to network stake since the proposed function can only be run in integer\nvalues. We choose to floor rather than ceil this value to prevent sybil attacks: otherwise a node could drastically\nincrease their probability of winning the random election by splitting their stake into many nodes with small stake."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"This protocol satisfies the ",o.createElement(t.strong,null,"safety")," property: if any node decides upon the leader of the random election during any\nround, then all nodes will eventually decide upon the same leader of the election for that round. This protocol does not\nsatisfy the ",o.createElement(t.strong,null,"liveness")," property: a single node, if they fail to send their VRF proof, can stall the network state\nindefinitely. We can utilize the Tendermint byzantine agreement to enforce liveness while maintaining network safety as\nlong as less than 1/3 of the nodes are faulty."),"\n",o.createElement("br"),"\n",o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," Implementation "),"\n",o.createElement(t.p,null,"To represent objects on the network, we use a simple binary format based on the BSON specification. Unlike BSON, it does\nnot have the capability to store key-value pairs. This allows us to send tuples of any type across the network. The\nbenefit of using this format over a common format like JSON is that messages can be serialized and deserialized far\nfaster than using JSON. The benefit of using this format over a simple binary representation such as that used by the\nBitcoin protocol is that nodes can determine the type of a tuple that it does not understand or expect. This allows for\neasier error handling."),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-fit"},o.createElement(i.p,{language:""},'tuple   ::= "(" e_list ")"\n\ne_list  ::= element e_list\n          | ""\n\nelement ::= tuple // nested tuple\n          | "i" int32_t  // big-endian 32-bit signed integer\n          | "I" int64_t  // big-endian 64-bit signed integer\n          | "u" uint32_t // big-endian 32-bit unsigned integer\n          | "U" uint64_t // big-endian 64-bit unsigned integer\n          | "f" float    // IEEE 754 single-precison float\n          | "F" double   // IEEE 754 double-precison float\n          | "b" bool     // 0x01 if true and 0x00 if false\n          | "B" buffer   // arbitrary binary data\n          | "s" string   // 0x00 terminated string\n          | "n"          // null\n\nbuffer ::= uint32_t uint8_t[]\n'))),"\n",o.createElement(t.p,null,'All network messages are composed of a message header and a message body. The message header contains a magic number\nwhich can be used to locate the start of a message in case a malformed message is sent, a domain specific integer\nrepresenting the message "type," the length of the message body, and a random GUID unique to the message. The body of\nall network messages are binary tuples.'),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-fit"},o.createElement(i.p,{language:""},'magic   ::= "0x54524a54"\nguid    ::= uint32_t uint32_t uint32_t uint32_t\ntype    ::= uint32_t\nlength  ::= uint32_t\nheader  ::= magic guid type length\nmessage ::= header tuple\n'))),"\n",o.createElement(t.p,null,"There are two classes of messages on the Whosecoin network: direct messages and broadcasted messages. A direct message\nhas a null guid. Any node which recieves a direct messages should act on the message, but need not forward the message\nto any other nodes. A broadcasted message has a non-null guid. Any node which receives a broadcasted message should\nforward the message to all of its peers unless it has already received a message with the same guid. Under this current\nsystem, a malicious node can prevent a message from reaching all nodes by modifying the message before forwarding it to\nits peers. If the incorrect message reaches a node before the correct message, the node will only act upon and forward\nthe incorrect message. This can be resolved by including a message signature in the message header which can replace the\nGUID in this scheme."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"We briefly highlight the network protocol message types below:"),"\n",o.createElement("br"),"\n",o.createElement("ul",{className:"list-disc list-inside"},o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"handshake"),": On connecting to the network, a node attempts to connect to all known peers.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"peer-request"),": After connecting to a peer, a node requests a list of the peer’s peers.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"peer-response"),": Upon receiving a list of a peer’s peers, a node attempts to connect to each one in turn.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"block-request"),": A node requests all blocks starting with current leaf node of principal blockchain.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"block-response"),": A node sends all blocks starting with the requested block.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"pool-request"),": A node requests all transactions in a peers transaction pool.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"pool-response"),": A node sends all transactions in their transaction pool.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"transaction"),": After receiving a transaction, a node adds the transaction to a pool of unconfirmed transactions.")),o.createElement("li",null,o.createElement(t.p,null,o.createElement(t.strong,null,"block"),": After receiving a block, a node adds the transaction to the blockchain database."))),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Shown below is the definitions for a block and a transaction in our code. The structs each have an equivalent typed\ntuple definition that is used to transmit them over the network."),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-fit"},o.createElement(i.p,{language:"c"},"struct block {\n    uint64_t  timestamp;\n    block_t  *prev_block;\n    list_t   *transactions;\n    uint8_t   merkle_root[crypto_generichash_BYTES];\n    uint8_t   public_key[crypto_vrf_PUBLICKEYBYTES];\n    uint8_t   signature[crypto_sign_BYTES];\n    uint8_t   sortition_proof[crypto_vrf_PROOFBYTES];\n    uint32_t  delegate;\n}\n"))),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full sm:w-fit"},o.createElement(i.p,{language:"c"},"struct transaction {\n    uint8_t  sender[crypto_sign_PUBLICKEYBYTES];\n    uint8_t  recipient[crypto_sign_PUBLICKEYBYTES];\n    uint64_t value;\n    uint32_t nonce;\n}\n"))),"\n",o.createElement(t.p,null,"Each node has the option to expose a simple REST API that allows users to query for the latest blocks on the blockchain,\nthe current balance for any account. Shown below is the React front-end that was created to visualize the results of the\nblockchain explorer API."),"\n",o.createElement("div",{className:"flex justify-center"},o.createElement("div",{className:"p-4 w-full"},o.createElement("img",{src:s,alt:"Whosecoin blockchain explorer",className:"w-full h-auto"}))),"\n",o.createElement("br"),"\n",o.createElement("p",{className:"font-bold text-lg sm:text-3xl"}," Possible Extensions "),"\n",o.createElement(t.p,null,"In its current state, the system defined above exemplifies excellent security (malicious nodes cannot stop the system\nfrom moving from block to block) at the cost of poor liveness (nodes can potentially withhold blocks until later\niterations and then roll back the system to a much earlier state). Due to time constraints, this was left unaddressed in\nthe basic framework implemented above, but can be solved by implementing a fault tolerance system. Namely, we would seek\nto implement Byzantine fault tolerance using a similar system to Tendermint, which guarantees liveness (while\nmaintaining safety) under the assumption that less than 1/3 of the nodes are malicious."),"\n",o.createElement("br"),"\n",o.createElement(t.p,null,"Additionally, the network currently operates through a shell, which is innately simple and might prove difficult for\npotential users to navigate. Should the network ever be implemented as a large-scale distribution, it would need to be\nadapted to include some kind of GUI. This was loosely done through the implementation of the blockchain explorer page,\nbut additional steps can (and should) be taken to polish it up for real use."))}var d=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?o.createElement(t,e,o.createElement(c,e)):c(e)},m=n(8678);const u=e=>{let{data:t,children:n}=e;return o.createElement(m.Z,{pageTitle:t.mdx.frontmatter.title,date:t.mdx.frontmatter.date},o.createElement("div",{className:"w-full sm:w-2/3"},n))},h=e=>{let{data:t}=e;return o.createElement("title",null,t.mdx.frontmatter.title)};function p(e){return o.createElement(u,e,o.createElement(d,e))}},7947:function(e,t,n){"use strict";var a=n(7294),o=n(7617);t.Z=e=>{let{displayMode:t,formula:n}=e;return"block"===t?a.createElement(o.BlockMath,null,n):a.createElement(o.InlineMath,null,n)}},7617:function(e,t,n){var a,o,i,r;r=function(e,t,n,a){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(i=function(e){return e?n:t})(e)}function r(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=i(t);if(n&&n.has(e))return n.get(e);var a={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in e)if("default"!==r&&Object.prototype.hasOwnProperty.call(e,r)){var l=o?Object.getOwnPropertyDescriptor(e,r):null;l&&(l.get||l.set)?Object.defineProperty(a,r,l):a[r]=e[r]}return a.default=e,n&&n.set(e,a),a}Object.defineProperty(e,"__esModule",{value:!0}),function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(e,{BlockMath:()=>m,InlineMath:()=>u}),t=r(t),n=o(n),a=o(a);const l=(e,{displayMode:o})=>{const i=({children:n,errorColor:i,math:r,renderError:l})=>{const s=null!=r?r:n,{html:c,error:d}=(0,t.useMemo)((()=>{try{return{html:a.default.renderToString(s,{displayMode:o,errorColor:i,throwOnError:!!l}),error:void 0}}catch(d){if(d instanceof a.default.ParseError||d instanceof TypeError)return{error:d};throw d}}),[s,i,l]);return d?l?l(d):t.default.createElement(e,{html:`${d.message}`}):t.default.createElement(e,{html:c})};return i.propTypes={children:n.default.string,errorColor:n.default.string,math:n.default.string,renderError:n.default.func},i},s={html:n.default.string.isRequired},c=({html:e})=>t.default.createElement("div",{"data-testid":"react-katex",dangerouslySetInnerHTML:{__html:e}});c.propTypes=s;const d=({html:e})=>t.default.createElement("span",{"data-testid":"react-katex",dangerouslySetInnerHTML:{__html:e}});d.propTypes=s;const m=l(c,{displayMode:!0}),u=l(d,{displayMode:!1})},"object"==typeof e.exports?r(t,n(7294),n(5697),n(527)):(o=[t,n(7294),n(5697),n(527)],void 0===(i="function"==typeof(a=r)?a.apply(t,o):a)||(e.exports=i))}}]);
//# sourceMappingURL=component---src-pages-projects-mdx-frontmatter-slug-js-content-file-path-users-michael-desktop-mogonzal-mogonzal-website-projects-cs-145-whosecoin-cs-145-whosecoin-mdx-32e5e039803e3e1d750b.js.map